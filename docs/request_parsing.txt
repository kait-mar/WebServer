request Message syntaxe:

Request_line : 
    {
        Method, URI, protocol version (http1.1)
    }
Header_fields :
    {
        request modifiers
        client information
        representatiom metadata
        empty line (the end)
    }

message_body:
    {
        the payload body (if any)
    }

            ****** example ******

Client request:
{
    GET /hello.txt HTTP/1.1
    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
    Host: www.example.com
    Accept-Language: en, mi
}
Server response:
{
    HTTP/1.1 200 OK
    Date: Mon, 27 Jul 2009 12:28:53 GMT
    Server: Apache
    Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
    ETag: "34aa387-d-1568eb00"
    Accept-Ranges: bytes
    Content-Length: 51
    Vary: Accept-Encoding
    Content-Type: text/plain

    Hello World! My payload includes a trailing CRLF
}

http-URI = "http:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
{
    The origin server for an "http" URI is identified by the authority
    component, which includes a host identifier and optional TCP port
    ([RFC3986], Section 3.2.2). The hierarchical path component and
    optional query component serve as an identifier for a potential
    target resource within that origin serverâ€™s name space. The optional
    fragment component allows for indirect identification of a secondary
    resource, independent of the URI scheme, as defined in Section 3.5 of
    [RFC3986].
    page 17
}

the both server response and client request are both http message. they only differ by the start line and and in the algorithm
 for determining the length of the message body 

1 /    request line syntaxe:
    method + [single space] + request-target + [single space] + http-version + CRLF
    - method : GET, POST, DELETE ...
        --------------------
2 /    status line :
    http-version + [space] + status-code + [space] + reason-phrase (textual describing status code maybe exists) + CRLF
    reason-phrase = *( HTAB / SP / VCHAR / obs-text )
        ---------------------

- Recipients of an invalid request-line SHOULD respond with either a
    400 (Bad Request) error or a 301 (Moved Permanently) redirect with
    the request-target properly encoded
-  A server that receives a
    method longer than any that it implements SHOULD respond with a 501
    (Not Implemented) status code.
- A server that receives a request-target longer than any URI it wishes to parse MUST respond
    with a 414 (URI Too Long) status code
- Various ad hoc limitations on request-line length are found in
    practice. It is RECOMMENDED that all HTTP senders and recipients
    support, at a minimum, request-line lengths of 8000 octets.

Header_fields :
{
    request modifiers
    client information
    representatiom metadata
    empty line (the end)
}
hello word \t !
{
    header-field = field-name ":" OWS field-value OWS
    field-name = token
    field-value = *( field-content / obs-fold )
    field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
    field-vchar = VCHAR(any visible character) / obs-text 
    obs-fold = CRLF 1*( SP / HTAB )
    ; obsolete line  folding
    ; see Section 3.2.4
}

conditions:
    - the filed names must be unique (no duplicated names) unless either the entire field
        value for that header field is defined as a comma-separated list [i.e., #(values]
        or the header field is a well-known exception 
- read about the set-coockie field name (page 24/  RFC 7230)
- read about whitesopace so important
- parsing :
    page 25, field-parsing
- A recipient MUST be able to parse the chunked transfer coding
- URI syntaxe
    ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
    wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]
page 15

-parsing header_field:
{
    *No whitespace is allowed between the header field-name and colon;

}