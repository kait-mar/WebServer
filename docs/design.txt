
- Concepts:

	
	* Connections handler:
		objectif: managing the connections
			- establishing new connection
			- detecting connection failure
			- closing connection
			- listen for (read/write) on the connection
			- close connection
		
		* Connection:
			- each connection is defined by a fd


		* Connection: two types of connections:
			- listening connection:
				* accept new client and create new data connection for it
				* logs the new connection
			- data connection:
				* handle messaging between client and server
				* a channel for (request / response)
				* support pipelining
				* capability of persistence
				+ has two buffers: input and output
					* read	request into input buffer
					* write response to output buffer


	* Executer:
		+	request
		+	response
		
		- using logger (for partial log)
		- construct request
			//	if (request.parse () is not ok)
			//		generate an appropriate error response.
			//	execute response
		- generate response

		- execute: has states
			* parsing:
				try parsing request
				if there is an error 
					set state to error state:
				if (SL and HF are parsed)
					set state to execute.
			* error:
				generate appropriate error response;
				set state to sending state; 
			* execute state
				* depending on the request
				* if payload is expected and request is not complete yet 
					request.recvpayload ()
				* apply URL mapping:
					- redirection
						generate redirection request;
					- static file
						generate static file request
					- cgi
						generate cgi request
				* 
			* sending
				send the response throw the connection




	* Message
		+ start line
		+ header fields
		+ payload
			; a buffer or a fd for storing ?	
		* reusing capability
			- reset message to blank
		* queue for receiving data or sending data
		* that handles read/write syscalls
		
	* Requist: Message
		* abilities for Parsing
			- request line (start line)
			- header fields
			- payload

	* Response

	* CGI

* Configuration: gloabbaly accessed
	- must be accessed from everywhere in the program
	- two kind of configuration
		* default confs
		* user confs:
			- some user confs can override some default confs.
		- 
	* Logger: must be gloabbaly accessed
		function:
			- logging of partial (request | response)
			- logging of new connection.
		where:
			- the logs files set in the confguration
			- standard output / error


* many objects share the same instance of configuration
* so configuration will be a singleton function 


// execution of dataConnection must be a state machine 
// reading and writing events into or from a std::string is bad for performance
// circullar buffer must be implemented


- if something in request was not acceptable (in status line or message headers), web server already sent an error response;
- if URL maps to a redirection then a redirect message is sent;
- if URL maps to a dynamic resource (a virtual path or a directory listing) then its handler (an internal module or an external program) is called and request parameters (query string and path info) are passed to it in order to allow it to reply to that request;
- if URL maps to a static resource (usually a file on file system) then the internal static handler is called to send that file;
- if request method is not known or if there is some other unacceptable condition (e.g. resource not found, internal server error, etc.) then an error response is sent.


The intercepting filter design pattern is used when we want to do some pre-processing / post-processing with request or response of the application. 
Filters are defined and applied on the request before passing the request to actual target application.

- Connection establishment and service initialization
- Event demultiplexing and event handler dispatching
- Interprocess communication (IPC) and network protocols
- Primary and secondary storage management and caching
- Static and dynamic component configuration
- Concurrency and synchronization

??? create a file cache component to avoid accessing the file system for each client request

protocol handler:
	- parses the request
	- logs the request
	- fetches file status information
	- updates the file cache
	- transmits the file back to the HTTP client
	- cleans up any resources it allocated.

File caching models:
	- least-recently used (LRU)
	- least-frequently used (LFU)

Protocol Handler:
	This implements the parsing and protocol processing of HTTP request events.
	allows multiple Web protocols, such as HTTP/1.0, HTTP/1.1.


design patterns:
	- Component Configuration
	- Acceptor/Connector
	- Leader/Follower
	- Reactor
	- Proactor
	- Wrapper Facade
	- Half-Sync/Half-Async
	- Monitor Object

- singleton for implementing Cached virtual filesystem

- Wrapper Facade: 	encapsulates low-level functions
					and data structures within more concise, robust, portable, and
					maintainable object-oriented class interfaces